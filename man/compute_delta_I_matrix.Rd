% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/signed_delta_I.R
\name{compute_delta_I_matrix}
\alias{compute_delta_I_matrix}
\title{Compute Full Delta I Matrix (Optimized for All Pairs)}
\usage{
compute_delta_I_matrix(
  expr_matrix,
  spot_coords,
  radii = seq(100, 600, 100),
  mode = c("bivariate", "directional"),
  sender_percentile = 75,
  chunk_size = 1000,
  smooth_window = 5,
  smooth_poly = 2,
  coord_scale = 1,
  verbose = TRUE
)
}
\arguments{
\item{expr_matrix}{A matrix of gene expression values (genes x spots). VST-normalized recommended.}

\item{spot_coords}{Spot coordinates as a data frame with row/col columns, or a 2-column matrix.}

\item{radii}{Numeric vector of distance bin edges. Default: seq(100, 600, 100).}

\item{mode}{Computation mode: "bivariate" (symmetric) or "directional" (I_ND). Default: "bivariate".}

\item{sender_percentile}{For directional mode: percentile threshold for senders. Default: 75.}

\item{chunk_size}{Number of genes per chunk for memory efficiency. Default: 1000. NULL disables chunking.}

\item{smooth_window}{Savitzky-Golay smoothing window size (must be odd). Default: 5.}

\item{smooth_poly}{Savitzky-Golay polynomial order. Default: 2.}

\item{coord_scale}{Scale factor for coordinates. Default: 1.}

\item{verbose}{Print progress messages. Default: TRUE.}
}
\value{
A list with delta_I_signed (n_genes x n_genes matrix), n_genes, n_spots, n_radii, radii.
}
\description{
Computes signed delta I for ALL gene pairs at once using an optimized
matrix multiplication approach. This is much faster than computing
delta I for each factor separately when you need the full matrix.
}
\details{
This function is optimized for computing delta I for ALL gene pairs at once.
In bivariate mode, the weight matrix W(r) is the SAME for all gene pairs at
a given radius. The optimization:
\enumerate{
  \item Precompute weight matrices once for all radii (6 matrices)
  \item Standardize all gene expressions once (Z matrix)
  \item For each radius, compute full I matrix: I(r) = Z * W(r) * Z^T / n
  \item Compute delta I for all pairs from the I(r) cube
}

This reduces weight matrix creation from O(n_factors * n_radii) to O(n_radii),
providing significant speedup when computing the full matrix.

For large gene sets (>5000), the function automatically uses a memory-efficient
chunked algorithm to avoid running out of memory.

The matrix is organized as: rows = target genes, columns = factor genes.
So \code{delta_I_signed[i, j]} gives the signed delta I for gene i when
gene j is used as the factor.
}
\examples{
\dontrun{
# Compute full delta I matrix for 500 genes
result <- compute_delta_I_matrix(
  expr_matrix = expr_vst[1:500, ],
  spot_coords = coords,
  coord_scale = 100,
  verbose = TRUE
)

# Access the matrix
delta_I <- result$delta_I_signed
dim(delta_I)  # 500 x 500

# Find top responders for gene 1 as factor
responders <- sort(delta_I[, 1], decreasing = TRUE)
head(responders)
}

}
\seealso{
\code{\link{compute_signed_delta_I}} for single-factor computation,
  \code{\link{get_moran_curve}} for individual pair analysis.
}
