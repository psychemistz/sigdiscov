# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compute I_ND Matrix for One Cell Type Pair at One Radius
#'
#' Matches Python MoransIMatrixComputer.compute_morans_matrix_batched()
#'
#' @param factor_expr_norm Normalized factor expression (n_sender_cells x n_factors)
#' @param factor_expr_raw Raw factor expression (for quantile threshold)
#' @param gene_expr_norm Normalized gene expression (n_receiver_cells x n_genes)
#' @param W Weight matrix (n_senders x n_receivers, row-normalized)
#' @param quantile_prob Quantile threshold (default: 0.25 = keep top 75 percent)
#' @param min_cells Minimum high-expression cells
#' @return Matrix of I_ND values (n_factors x n_genes)
#' @export
compute_ind_matrix_cpp <- function(factor_expr_norm, factor_expr_raw, gene_expr_norm, W, quantile_prob = 0.25, min_cells = 10L) {
    .Call(`_sigdiscov_compute_ind_matrix_cpp`, factor_expr_norm, factor_expr_raw, gene_expr_norm, W, quantile_prob, min_cells)
}

#' Batch Compute All Cell Type Pairs at All Radii
#'
#' Matches Python run_matrix_analysis() output format.
#'
#' @param expr_matrix Expression matrix (genes x cells)
#' @param coords Cell coordinates (cells x 2)
#' @param cell_types Cell type vector
#' @param factor_indices Factor gene indices (0-based)
#' @param radii Distance radii vector
#' @param pairs DataFrame with sender, receiver columns
#' @param quantile_prob Quantile threshold
#' @param min_cells Minimum cells per group
#' @param min_connections Minimum neighbors in weight matrix
#' @param verbose Print progress
#' @return List of cubes (one per radius), each is (n_pairs x n_factors x n_genes)
#' @export
batch_compute_all_pairs_cpp <- function(expr_matrix, coords, cell_types, factor_indices, radii, pairs, quantile_prob = 0.25, min_cells = 10L, min_connections = 10L, verbose = TRUE) {
    .Call(`_sigdiscov_batch_compute_all_pairs_cpp`, expr_matrix, coords, cell_types, factor_indices, radii, pairs, quantile_prob, min_cells, min_connections, verbose)
}

#' Compute Bivariate Moran's I from Pre-computed Spatial Lag
#'
#' Calculates Moran's I statistic using the formula:
#'   I = z_f' * lag_g / n
#'
#' where lag_g = W * z_g has been pre-computed.
#'
#' @param z_f Standardized factor expression vector (length n)
#' @param lag_g Pre-computed spatial lag of gene (W * z_g), same length as z_f
#'
#' @return Scalar Moran's I value (unbounded)
#'
#' @details
#' Moran's I measures spatial autocorrelation. Positive values indicate
#' spatial clustering (similar values near each other), negative values
#' indicate dispersion (dissimilar values near each other).
#'
#' @export
compute_moran_from_lag_cpp <- function(z_f, lag_g) {
    .Call(`_sigdiscov_compute_moran_from_lag_cpp`, z_f, lag_g)
}

#' Compute I_ND (Cosine Similarity) from Pre-computed Spatial Lag
#'
#' Calculates the normalized directional Moran's I (I_ND) using:
#'   I_ND = z_f' * lag_g / (||z_f|| * ||lag_g||)
#'
#' This is equivalent to the cosine similarity between z_f and lag_g.
#'
#' @param z_f Standardized factor expression vector (length n)
#' @param lag_g Pre-computed spatial lag of gene (W * z_g)
#'
#' @return Scalar I_ND value bounded between -1 and 1, or NA if norms are too small
#'
#' @details
#' I_ND is the cosine of the angle between z_f and the spatial lag of z_g.
#' It is bounded between -1 and 1, making it interpretable as a correlation:
#'   +1: Perfect positive spatial association
#'    0: No spatial association
#'   -1: Perfect negative spatial association
#'
#' Returns NA if either vector has near-zero norm (constant or zero expression).
#'
#' @export
compute_ind_from_lag_cpp <- function(z_f, lag_g) {
    .Call(`_sigdiscov_compute_ind_from_lag_cpp`, z_f, lag_g)
}

#' Batch Compute Metrics for All Genes
#'
#' Efficiently computes Moran's I or I_ND for one factor against all genes
#' using pre-computed spatial lag matrix.
#'
#' This is the workhorse function for genome-wide analysis: compute the
#' spatial lag matrix once (W * Z_g), then call this function to get
#' metrics for all genes in one vectorized operation.
#'
#' @param z_f Standardized factor expression (length n)
#' @param lag_G Pre-computed spatial lag matrix (n x n_genes)
#'        Each column is W * z_g for one gene
#' @param metric String: "moran" or "ind"
#'
#' @return Numeric vector of metric values (length n_genes)
#'
#' @details
#' For "moran": I_g = z_f' * lag_G_g / n for each gene g
#' For "ind": I_g = z_f' * lag_G_g / (||z_f|| * ||lag_G_g||) for each gene g
#'
#' The function is optimized using vectorized operations where possible.
#'
#' @export
compute_metric_batch_cpp <- function(z_f, lag_G, metric) {
    .Call(`_sigdiscov_compute_metric_batch_cpp`, z_f, lag_G, metric)
}

#' Standardize a Vector (Z-score)
#'
#' @param x Numeric vector
#' @return Standardized vector (mean=0, sd=1)
#'
#' @details
#' Computes (x - mean(x)) / sd(x). Uses population standard deviation (N, not N-1).
#' If sd is near zero (constant vector), returns zeros.
#'
#' @keywords internal
standardize_vec_cpp <- function(x) {
    .Call(`_sigdiscov_standardize_vec_cpp`, x)
}

#' Standardize Matrix Row-wise (Gene-wise Z-score)
#'
#' @param X Numeric matrix (genes x observations)
#' @return Row-wise standardized matrix
#'
#' @details
#' Each row is independently standardized to have mean 0 and sd 1.
#' This is the standard preprocessing for expression matrices where
#' genes are rows and observations (spots/cells) are columns.
#'
#' @keywords internal
standardize_matrix_cpp <- function(X) {
    .Call(`_sigdiscov_standardize_matrix_cpp`, X)
}

cpp_create_distance <- function(max_shift, mode) {
    .Call(`_sigdiscov_cpp_create_distance`, max_shift, mode)
}

cpp_z_normalize <- function(data) {
    .Call(`_sigdiscov_cpp_z_normalize`, data)
}

cpp_create_weight_matrix <- function(spot_row, spot_col, distance, max_shift, flag_samespot) {
    .Call(`_sigdiscov_cpp_create_weight_matrix`, spot_row, spot_col, distance, max_shift, flag_samespot)
}

cpp_pairwise_moran <- function(data, W, weight_sum, paired_genes = TRUE, all_genes = TRUE) {
    .Call(`_sigdiscov_cpp_pairwise_moran`, data, W, weight_sum, paired_genes, all_genes)
}

cpp_pairwise_moran_sparse <- function(data_sparse, W, weight_sum, paired_genes = TRUE, all_genes = TRUE) {
    .Call(`_sigdiscov_cpp_pairwise_moran_sparse`, data_sparse, W, weight_sum, paired_genes, all_genes)
}

cpp_compute_moran_full <- function(data, spot_row, spot_col, max_radius = 5L, platform = 0L, flag_samespot = TRUE, paired_genes = TRUE, all_genes = TRUE, verbose = TRUE) {
    .Call(`_sigdiscov_cpp_compute_moran_full`, data, spot_row, spot_col, max_radius, platform, flag_samespot, paired_genes, all_genes, verbose)
}

cpp_compute_moran_full_sparse <- function(data_sparse, spot_row, spot_col, max_radius = 5L, platform = 0L, flag_samespot = TRUE, paired_genes = TRUE, all_genes = TRUE, verbose = TRUE) {
    .Call(`_sigdiscov_cpp_compute_moran_full_sparse`, data_sparse, spot_row, spot_col, max_radius, platform, flag_samespot, paired_genes, all_genes, verbose)
}

cpp_create_weight_matrix_sparse <- function(spot_row, spot_col, distance, max_shift, flag_samespot) {
    .Call(`_sigdiscov_cpp_create_weight_matrix_sparse`, spot_row, spot_col, distance, max_shift, flag_samespot)
}

cpp_pairwise_moran_W_sparse <- function(data, W, weight_sum, paired_genes = TRUE, all_genes = TRUE) {
    .Call(`_sigdiscov_cpp_pairwise_moran_W_sparse`, data, W, weight_sum, paired_genes, all_genes)
}

cpp_compute_moran_full_W_sparse <- function(data, spot_row, spot_col, max_radius = 5L, platform = 0L, flag_samespot = TRUE, paired_genes = TRUE, all_genes = TRUE, verbose = TRUE) {
    .Call(`_sigdiscov_cpp_compute_moran_full_W_sparse`, data, spot_row, spot_col, max_radius, platform, flag_samespot, paired_genes, all_genes, verbose)
}

#' Permutation Test for Spatial Correlation (Single Gene)
#'
#' Tests H0: No spatial association between factor and gene expression.
#' The test permutes factor expression while keeping the spatial lag fixed.
#'
#' @param z_f Standardized factor expression vector (length n)
#' @param lag_g Pre-computed spatial lag of gene (W * z_g), same length as z_f
#' @param metric String: "moran" for bivariate Moran's I, "ind" for I_ND
#' @param n_perm Number of permutations (default: 999)
#'
#' @return List with components:
#'   - I_obs: Observed statistic value
#'   - p_value: Two-sided p-value with continuity correction
#'   - z_score: Z-score relative to null distribution
#'   - null_mean: Mean of null distribution
#'   - null_sd: Standard deviation of null distribution
#'   - n_perm: Number of permutations performed
#'
#' @details
#' The permutation strategy is:
#' 1. Compute observed statistic from z_f and lag_g
#' 2. For b = 1 to n_perm:
#'    a. Randomly permute z_f
#'    b. Compute permuted statistic (lag_g stays fixed)
#' 3. p-value = (1 + count(|I_perm| >= |I_obs|)) / (n_perm + 1)
#'
#' The continuity correction (+1 in numerator and denominator) ensures
#' p-values are never exactly 0.
#'
#' @export
permutation_test_cpp <- function(z_f, lag_g, metric, n_perm) {
    .Call(`_sigdiscov_permutation_test_cpp`, z_f, lag_g, metric, n_perm)
}

#' Batch Permutation Test for Multiple Genes
#'
#' Efficiently tests all genes against one factor. Pre-generates permutation
#' indices once and reuses them across all genes.
#'
#' @param z_f Standardized factor expression vector (length n_obs)
#' @param Z_g Gene expression matrix (n_obs x n_genes), genes in columns
#' @param W Sparse weight matrix (n_obs x n_obs) for computing spatial lags
#' @param metric String: "moran" or "ind"
#' @param n_perm Number of permutations (default: 999)
#' @param weight_sum Sum of weights for normalization. If <= 0, uses n_obs.
#'
#' @return DataFrame with columns:
#'   - gene_idx: Gene index (1-based)
#'   - I_obs: Observed statistic (Moran's I or I_ND)
#'   - p_value: Two-sided p-value
#'   - z_score: Z-score relative to null
#'   - null_sd: Standard deviation of the null distribution
#'
#' @details
#' Key optimizations:
#' 1. Permutation indices are generated ONCE and reused for all genes
#' 2. Spatial lag is computed once per gene
#' 3. User interrupt is checked every 100 genes
#'
#' This function is the workhorse for genome-wide significance testing.
#' For a typical analysis with 20,000 genes and 999 permutations, this
#' processes approximately 20 million permutation statistics.
#'
#' @export
batch_permutation_test_cpp <- function(z_f, Z_g, W, metric, n_perm, weight_sum = -1.0) {
    .Call(`_sigdiscov_batch_permutation_test_cpp`, z_f, Z_g, W, metric, n_perm, weight_sum)
}

#' All-Pairs Permutation Test for Pairwise Moran's I
#'
#' Fast C++ implementation of permutation testing for the full pairwise
#' Moran's I matrix. This function is called by the R wrapper moran_permutation_test().
#'
#' @param data_z Z-normalized expression matrix (genes x spots)
#' @param W Dense weight matrix (spots x spots)
#' @param S0 Sum of all weights
#' @param n_perm Number of permutations
#' @param seed Random seed for reproducibility (0 = use random seed)
#' @param verbose Print progress messages
#'
#' @return List containing:
#'   - sum: Sum of Moran's I across permutations
#'   - sum_sq: Sum of squared Moran's I
#'   - count_extreme: Count of permutations with |I_perm| >= |I_obs|
#'   - observed: Observed Moran's I matrix
#'
#' @keywords internal
allpairs_permutation_test_cpp <- function(data_z, W, S0, n_perm, seed = 0L, verbose = TRUE) {
    .Call(`_sigdiscov_allpairs_permutation_test_cpp`, data_z, W, S0, n_perm, seed, verbose)
}

#' Fast Pairwise Moran's I Computation
#'
#' Computes pairwise Moran's I for all gene pairs using optimized BLAS
#' matrix operations.
#'
#' @param data_z Z-normalized expression matrix (genes x spots)
#' @param W Weight matrix (spots x spots)
#' @param S0 Sum of all weights
#'
#' @return Moran's I matrix (genes x genes)
#'
#' @keywords internal
pairwise_moran_matrix_cpp <- function(data_z, W, S0) {
    .Call(`_sigdiscov_pairwise_moran_matrix_cpp`, data_z, W, S0)
}

#' Z-Normalize Expression Matrix
#'
#' Z-normalizes each row (gene) of the expression matrix.
#'
#' @param X Expression matrix (genes x spots)
#'
#' @return Z-normalized matrix
#'
#' @keywords internal
z_normalize_matrix_cpp <- function(X) {
    .Call(`_sigdiscov_z_normalize_matrix_cpp`, X)
}

#' Univariate Moran's I for Each Gene
#'
#' Computes univariate Moran's I for each gene (diagonal of pairwise matrix).
#'
#' @param data_z Z-normalized expression matrix (genes x spots)
#' @param W Weight matrix (spots x spots)
#' @param S0 Sum of all weights
#'
#' @return Vector of Moran's I values
#'
#' @keywords internal
single_gene_moran_cpp <- function(data_z, W, S0) {
    .Call(`_sigdiscov_single_gene_moran_cpp`, data_z, W, S0)
}

#' Row-Normalize Sparse Matrix
#'
#' @param W Sparse matrix (n x m)
#' @return Row-normalized sparse matrix where each row sums to 1 (or 0)
sparse_row_normalize_cpp <- function(W) {
    .Call(`_sigdiscov_sparse_row_normalize_cpp`, W)
}

#' Create Gaussian Weight Matrix for Single-Cell Data
#'
#' Matches Python implementation: sigma = radius / 3
#'
#' @param sender_coords Sender cell coordinates (n_s x 2)
#' @param receiver_coords Receiver cell coordinates (n_r x 2)
#' @param radius Outer radius (micrometers)
#' @param inner_radius Inner radius for ring (default: 0)
#' @param sigma Gaussian sigma (default: radius/3)
#' @param min_weight Minimum weight threshold (default: 1e-6)
#' @return Sparse weight matrix (n_s x n_r), row-normalized
#' @export
create_gaussian_weights_cpp <- function(sender_coords, receiver_coords, radius, inner_radius = 0.0, sigma = -1.0, min_weight = 1e-6) {
    .Call(`_sigdiscov_create_gaussian_weights_cpp`, sender_coords, receiver_coords, radius, inner_radius, sigma, min_weight)
}

#' Create Gaussian Ring Weight Matrix
#'
#' Weight matrix for annular region between inner and outer radius.
#'
#' @param coords Cell coordinates (n x 2)
#' @param outer_radius Outer radius
#' @param inner_radius Inner radius
#' @param sigma Gaussian sigma (default: outer_radius/3)
#' @return Sparse weight matrix (n x n), row-normalized
#' @export
create_gaussian_ring_weights_cpp <- function(coords, outer_radius, inner_radius, sigma = -1.0) {
    .Call(`_sigdiscov_create_gaussian_ring_weights_cpp`, coords, outer_radius, inner_radius, sigma)
}

#' Create Circular RBF Weight Matrix
#'
#' Computes a sparse weight matrix using RBF kernel with circular (Euclidean)
#' distance cutoff. This matches the SpaCET calWeights behavior.
#'
#' @param coords Spot coordinates matrix (n x 2), physical units (e.g., micrometers)
#' @param radius Distance cutoff. Only spots within this radius are connected.
#' @param sigma RBF kernel bandwidth. Default: 100.
#' @param include_self Include self-connections (diagonal). Default: FALSE.
#'
#' @return A list containing:
#'   \item{W}{Sparse weight matrix (n x n), NOT row-normalized}
#'   \item{weight_sum}{Sum of all weights (S0 for Moran's I normalization)}
#'
#' @details
#' The weight is computed as:
#' \deqn{w_{ij} = \exp\left(-\frac{d_{ij}^2}{2\sigma^2}\right) \text{ if } d_{ij} \leq r}
#'
#' where \eqn{d_{ij}} is the Euclidean distance between spots i and j.
#'
#' This function is designed to match SpaCET's calWeights behavior for
#' spatial correlation analysis.
#'
#' @export
create_circular_weights_cpp <- function(coords, radius, sigma = 100.0, include_self = FALSE) {
    .Call(`_sigdiscov_create_circular_weights_cpp`, coords, radius, sigma, include_self)
}

#' Create Circular RBF Weight Matrix (Dense Version)
#'
#' Same as create_circular_weights_cpp but returns a dense matrix.
#' Useful when sparsity is low or for compatibility with functions
#' expecting dense matrices.
#'
#' @param coords Spot coordinates matrix (n x 2)
#' @param radius Distance cutoff
#' @param sigma RBF kernel bandwidth. Default: 100.
#' @param include_self Include self-connections. Default: FALSE.
#'
#' @return A list containing:
#'   \item{W}{Dense weight matrix (n x n)}
#'   \item{weight_sum}{Sum of all weights}
#'
#' @export
create_circular_weights_dense_cpp <- function(coords, radius, sigma = 100.0, include_self = FALSE) {
    .Call(`_sigdiscov_create_circular_weights_dense_cpp`, coords, radius, sigma, include_self)
}

#' Create Binary Weight Matrix for Visium
#'
#' Computes a row-normalized binary weight matrix where all spots within
#' the specified radius receive equal weight.
#'
#' @param coords Spot coordinates matrix (n x 2)
#' @param radius Distance threshold for neighbor definition
#' @param include_self Include self-connections (default: FALSE)
#'
#' @return Sparse weight matrix (n x n), row-normalized so each row sums to 1
#'
#' @details
#' The weight is computed as:
#' \deqn{w_{ij} = \frac{1}{n_i} \text{ if } d(i,j) \leq r, \text{ else } 0}
#'
#' where \eqn{n_i} is the number of neighbors for spot i.
#'
#' @export
create_binary_weights_cpp <- function(coords, radius, include_self = FALSE) {
    .Call(`_sigdiscov_create_binary_weights_cpp`, coords, radius, include_self)
}

#' Create Ring Weight Matrix for Visium
#'
#' Computes a weight matrix where only spots in a ring (annulus) between
#' inner and outer radii receive weight. Useful for excluding immediate
#' neighbors or analyzing specific distance bands.
#'
#' @param coords Spot coordinates matrix (n x 2)
#' @param inner_radius Inner radius (exclusive)
#' @param outer_radius Outer radius (inclusive)
#'
#' @return Sparse ring weight matrix (n x n), row-normalized
#'
#' @details
#' Weight is assigned to spots where \eqn{r_{inner} < d(i,j) \leq r_{outer}}.
#'
#' @export
create_ring_weights_cpp <- function(coords, inner_radius, outer_radius) {
    .Call(`_sigdiscov_create_ring_weights_cpp`, coords, inner_radius, outer_radius)
}

#' Create Directional Weight Matrix (Sender to Receiver)
#'
#' Computes a weight matrix for directional analysis where senders and
#' receivers are different sets of spots. Used for expression-based
#' sender/receiver splitting in Visium analysis.
#'
#' @param sender_coords Sender spot coordinates (n_s x 2)
#' @param receiver_coords Receiver spot coordinates (n_r x 2)
#' @param radius Distance threshold
#'
#' @return Sparse weight matrix (n_senders x n_receivers), row-normalized
#'
#' @details
#' For directional mode, the weight matrix is not square. Each sender spot
#' gets connections to receiver spots within the radius, with row normalization
#' so that weights sum to 1 per sender.
#'
#' @export
create_directional_weights_cpp <- function(sender_coords, receiver_coords, radius) {
    .Call(`_sigdiscov_create_directional_weights_cpp`, sender_coords, receiver_coords, radius)
}

