# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compute I_ND Matrix for One Cell Type Pair at One Radius
#'
#' Matches Python MoransIMatrixComputer.compute_morans_matrix_batched()
#'
#' @param factor_expr_norm Normalized factor expression (n_sender_cells x n_factors)
#' @param factor_expr_raw Raw factor expression (for quantile threshold)
#' @param gene_expr_norm Normalized gene expression (n_receiver_cells x n_genes)
#' @param W Weight matrix (n_senders x n_receivers, row-normalized)
#' @param quantile_prob Quantile threshold (default: 0.25 = keep top 75 percent)
#' @param min_cells Minimum high-expression cells
#' @return Matrix of I_ND values (n_factors x n_genes)
#' @export
compute_ind_matrix_cpp <- function(factor_expr_norm, factor_expr_raw, gene_expr_norm, W, quantile_prob = 0.25, min_cells = 10L) {
    .Call(`_sigdiscov_compute_ind_matrix_cpp`, factor_expr_norm, factor_expr_raw, gene_expr_norm, W, quantile_prob, min_cells)
}

#' Batch Compute All Cell Type Pairs at All Radii
#'
#' Matches Python run_matrix_analysis() output format.
#'
#' @param expr_matrix Expression matrix (genes x cells)
#' @param coords Cell coordinates (cells x 2)
#' @param cell_types Cell type vector
#' @param factor_indices Factor gene indices (0-based)
#' @param radii Distance radii vector
#' @param pairs DataFrame with sender, receiver columns
#' @param quantile_prob Quantile threshold
#' @param min_cells Minimum cells per group
#' @param min_connections Minimum neighbors in weight matrix
#' @param verbose Print progress
#' @return List of cubes (one per radius), each is (n_pairs x n_factors x n_genes)
#' @export
batch_compute_all_pairs_cpp <- function(expr_matrix, coords, cell_types, factor_indices, radii, pairs, quantile_prob = 0.25, min_cells = 10L, min_connections = 10L, verbose = TRUE) {
    .Call(`_sigdiscov_batch_compute_all_pairs_cpp`, expr_matrix, coords, cell_types, factor_indices, radii, pairs, quantile_prob, min_cells, min_connections, verbose)
}

#' Compute Bivariate Moran's I from Pre-computed Spatial Lag
#'
#' Calculates Moran's I statistic using the formula:
#'   I = z_f' * lag_g / n
#'
#' where lag_g = W * z_g has been pre-computed.
#'
#' @param z_f Standardized factor expression vector (length n)
#' @param lag_g Pre-computed spatial lag of gene (W * z_g), same length as z_f
#'
#' @return Scalar Moran's I value (unbounded)
#'
#' @details
#' Moran's I measures spatial autocorrelation. Positive values indicate
#' spatial clustering (similar values near each other), negative values
#' indicate dispersion (dissimilar values near each other).
#'
#' @export
compute_moran_from_lag_cpp <- function(z_f, lag_g) {
    .Call(`_sigdiscov_compute_moran_from_lag_cpp`, z_f, lag_g)
}

#' Compute I_ND (Cosine Similarity) from Pre-computed Spatial Lag
#'
#' Calculates the normalized directional Moran's I (I_ND) using:
#'   I_ND = z_f' * lag_g / (||z_f|| * ||lag_g||)
#'
#' This is equivalent to the cosine similarity between z_f and lag_g.
#'
#' @param z_f Standardized factor expression vector (length n)
#' @param lag_g Pre-computed spatial lag of gene (W * z_g)
#'
#' @return Scalar I_ND value bounded between -1 and 1, or NA if norms are too small
#'
#' @details
#' I_ND is the cosine of the angle between z_f and the spatial lag of z_g.
#' It is bounded between -1 and 1, making it interpretable as a correlation:
#'   +1: Perfect positive spatial association
#'    0: No spatial association
#'   -1: Perfect negative spatial association
#'
#' Returns NA if either vector has near-zero norm (constant or zero expression).
#'
#' @export
compute_ind_from_lag_cpp <- function(z_f, lag_g) {
    .Call(`_sigdiscov_compute_ind_from_lag_cpp`, z_f, lag_g)
}

#' Batch Compute Metrics for All Genes
#'
#' Efficiently computes Moran's I or I_ND for one factor against all genes
#' using pre-computed spatial lag matrix.
#'
#' This is the workhorse function for genome-wide analysis: compute the
#' spatial lag matrix once (W * Z_g), then call this function to get
#' metrics for all genes in one vectorized operation.
#'
#' @param z_f Standardized factor expression (length n)
#' @param lag_G Pre-computed spatial lag matrix (n x n_genes)
#'        Each column is W * z_g for one gene
#' @param metric String: "moran" or "ind"
#'
#' @return Numeric vector of metric values (length n_genes)
#'
#' @details
#' For "moran": I_g = z_f' * lag_G_g / n for each gene g
#' For "ind": I_g = z_f' * lag_G_g / (||z_f|| * ||lag_G_g||) for each gene g
#'
#' The function is optimized using vectorized operations where possible.
#'
#' @export
compute_metric_batch_cpp <- function(z_f, lag_G, metric) {
    .Call(`_sigdiscov_compute_metric_batch_cpp`, z_f, lag_G, metric)
}

#' Standardize a Vector (Z-score)
#'
#' @param x Numeric vector
#' @return Standardized vector (mean=0, sd=1)
#'
#' @details
#' Computes (x - mean(x)) / sd(x). Uses population standard deviation (N, not N-1).
#' If sd is near zero (constant vector), returns zeros.
#'
#' @keywords internal
standardize_vec_cpp <- function(x) {
    .Call(`_sigdiscov_standardize_vec_cpp`, x)
}

#' Standardize Matrix Row-wise (Gene-wise Z-score)
#'
#' @param X Numeric matrix (genes x observations)
#' @return Row-wise standardized matrix
#'
#' @details
#' Each row is independently standardized to have mean 0 and sd 1.
#' This is the standard preprocessing for expression matrices where
#' genes are rows and observations (spots/cells) are columns.
#'
#' @keywords internal
standardize_matrix_cpp <- function(X) {
    .Call(`_sigdiscov_standardize_matrix_cpp`, X)
}

#' Create Directional Weight Matrix for Single-Cell Cell Type Pair Analysis
#'
#' Creates a sparse Gaussian weight matrix for sender->receiver cell type pairs.
#' Weights are computed from sender cells to receiver cells within radius.
#' Uses KD-tree for efficient neighbor search on large datasets.
#' Supports annular (ring) weights via inner_radius parameter.
#'
#' @param sender_coords Sender cell coordinates (n_sender x 2)
#' @param receiver_coords Receiver cell coordinates (n_receiver x 2)
#' @param radius Distance radius (outer radius) in same units as coordinates
#' @param inner_radius Inner radius for annular weights (default: 0, circular)
#' @param sigma Gaussian sigma (default: radius/3)
#' @param use_kdtree Use KD-tree for large datasets (default: TRUE)
#' @param verbose Print progress messages (default: FALSE)
#' @return List with W (sparse n_sender x n_receiver), weight_sum, n_edges
#' @export
create_directional_weights_sc_cpp <- function(sender_coords, receiver_coords, radius, inner_radius = 0.0, sigma = -1.0, use_kdtree = TRUE, verbose = FALSE) {
    .Call(`_sigdiscov_create_directional_weights_sc_cpp`, sender_coords, receiver_coords, radius, inner_radius, sigma, use_kdtree, verbose)
}

#' Compute Directional Pairwise Moran's I for Cell Type Pairs
#'
#' Computes gene x gene Moran's I matrix for sender->receiver cell type pairs.
#' Formula: \code{I_ij = Z_sender_i * W * Z_receiver_j^T / S0}
#'
#' @param sender_data Gene expression for sender cells (genes x n_sender), pre-normalized
#' @param receiver_data Gene expression for receiver cells (genes x n_receiver), pre-normalized
#' @param W Sparse directional weight matrix (n_sender x n_receiver), row-normalized
#' @param verbose Print progress messages (default: FALSE)
#' @return List with moran matrix (genes x genes) and weight_sum
#' @export
pairwise_moran_directional_cpp <- function(sender_data, receiver_data, W, verbose = FALSE) {
    .Call(`_sigdiscov_pairwise_moran_directional_cpp`, sender_data, receiver_data, W, verbose)
}

#' Compute Directional Pairwise Moran's I with Streaming (Memory Efficient)
#'
#' Computes directional Moran's I without storing the full weight matrix.
#' Uses KD-tree for efficient neighbor search. Best for large cell counts.
#'
#' IMPORTANT: For correct results, data should be GLOBALLY pre-normalized
#' (z-scored across ALL cells, not just sender or receiver subsets).
#' Use standardize_matrix() on the full expression matrix, then extract
#' sender and receiver subsets.
#'
#' @param sender_data Gene expression for sender cells (genes x n_sender),
#'   should be globally pre-normalized
#' @param receiver_data Gene expression for receiver cells (genes x n_receiver),
#'   should be globally pre-normalized
#' @param sender_coords Sender cell coordinates (n_sender x 2)
#' @param receiver_coords Receiver cell coordinates (n_receiver x 2)
#' @param radius Distance radius
#' @param sigma Gaussian sigma (default: radius/3)
#' @param normalize_data If TRUE, applies LOCAL z-normalization within each
#'   subset (NOT recommended - use globally pre-normalized data instead).
#'   Default: FALSE
#' @param verbose Print progress messages (default: TRUE)
#' @return List with moran matrix, weight_sum, n_edges
#' @export
pairwise_moran_directional_streaming_cpp <- function(sender_data, receiver_data, sender_coords, receiver_coords, radius, sigma = -1.0, normalize_data = FALSE, verbose = TRUE) {
    .Call(`_sigdiscov_pairwise_moran_directional_streaming_cpp`, sender_data, receiver_data, sender_coords, receiver_coords, radius, sigma, normalize_data, verbose)
}

#' Compute Delta I from I(r) Curves (Batch)
#'
#' Efficiently computes delta I for multiple radii curves.
#' Delta I = sign(I_short - I_long) * (I_max - I_min)
#'
#' @param I_curves 3D array of I values (n_pairs x n_genes x n_genes x n_radii) stored as
#'        a matrix where each row is a flattened curve for one gene pair
#' @return List with delta_I, I_max, argmax matrices
#' @export
compute_delta_i_batch_cpp <- function(I_curves) {
    .Call(`_sigdiscov_compute_delta_i_batch_cpp`, I_curves)
}

#' Compute Cell Type Pair Analysis for Multiple Radii
#'
#' Main function for computing Moran's I across multiple radii for a single
#' cell type pair. Returns I(r) curves for delta I computation.
#'
#' IMPORTANT: For correct results, data should be GLOBALLY pre-normalized
#' (z-scored across ALL cells, not just sender or receiver subsets).
#' Use standardize_matrix() on the full expression matrix, then extract
#' sender and receiver subsets.
#'
#' @param sender_data Gene expression for sender cells (genes x n_sender),
#'   should be globally pre-normalized
#' @param receiver_data Gene expression for receiver cells (genes x n_receiver),
#'   should be globally pre-normalized
#' @param sender_coords Sender cell coordinates (n_sender x 2)
#' @param receiver_coords Receiver cell coordinates (n_receiver x 2)
#' @param radii Vector of distance radii to compute
#' @param sigma_factor Sigma = radius * sigma_factor (default: 1/3)
#' @param normalize_data If TRUE, applies LOCAL z-normalization within each
#'   subset (NOT recommended - use globally pre-normalized data instead).
#'   Default: FALSE
#' @param verbose Print progress messages (default: TRUE)
#' @return List with I_curves (n_radii x n_genes x n_genes), delta_I, I_max, argmax
#' @export
compute_celltype_pair_moran_cpp <- function(sender_data, receiver_data, sender_coords, receiver_coords, radii, sigma_factor = 0.333333, normalize_data = FALSE, verbose = TRUE) {
    .Call(`_sigdiscov_compute_celltype_pair_moran_cpp`, sender_data, receiver_data, sender_coords, receiver_coords, radii, sigma_factor, normalize_data, verbose)
}

cpp_create_distance <- function(max_shift, mode) {
    .Call(`_sigdiscov_cpp_create_distance`, max_shift, mode)
}

cpp_z_normalize <- function(data) {
    .Call(`_sigdiscov_cpp_z_normalize`, data)
}

cpp_create_weight_matrix <- function(spot_row, spot_col, distance, max_shift, flag_samespot) {
    .Call(`_sigdiscov_cpp_create_weight_matrix`, spot_row, spot_col, distance, max_shift, flag_samespot)
}

cpp_pairwise_moran <- function(data, W, weight_sum, paired_genes = TRUE, all_genes = TRUE) {
    .Call(`_sigdiscov_cpp_pairwise_moran`, data, W, weight_sum, paired_genes, all_genes)
}

cpp_pairwise_moran_sparse <- function(data_sparse, W, weight_sum, paired_genes = TRUE, all_genes = TRUE) {
    .Call(`_sigdiscov_cpp_pairwise_moran_sparse`, data_sparse, W, weight_sum, paired_genes, all_genes)
}

cpp_compute_moran_full <- function(data, spot_row, spot_col, max_radius = 5L, platform = 0L, flag_samespot = TRUE, paired_genes = TRUE, all_genes = TRUE, verbose = TRUE) {
    .Call(`_sigdiscov_cpp_compute_moran_full`, data, spot_row, spot_col, max_radius, platform, flag_samespot, paired_genes, all_genes, verbose)
}

cpp_compute_moran_full_sparse <- function(data_sparse, spot_row, spot_col, max_radius = 5L, platform = 0L, flag_samespot = TRUE, paired_genes = TRUE, all_genes = TRUE, verbose = TRUE) {
    .Call(`_sigdiscov_cpp_compute_moran_full_sparse`, data_sparse, spot_row, spot_col, max_radius, platform, flag_samespot, paired_genes, all_genes, verbose)
}

cpp_create_weight_matrix_sparse <- function(spot_row, spot_col, distance, max_shift, flag_samespot) {
    .Call(`_sigdiscov_cpp_create_weight_matrix_sparse`, spot_row, spot_col, distance, max_shift, flag_samespot)
}

cpp_pairwise_moran_W_sparse <- function(data, W, weight_sum, paired_genes = TRUE, all_genes = TRUE) {
    .Call(`_sigdiscov_cpp_pairwise_moran_W_sparse`, data, W, weight_sum, paired_genes, all_genes)
}

cpp_compute_moran_full_W_sparse <- function(data, spot_row, spot_col, max_radius = 5L, platform = 0L, flag_samespot = TRUE, paired_genes = TRUE, all_genes = TRUE, verbose = TRUE) {
    .Call(`_sigdiscov_cpp_compute_moran_full_W_sparse`, data, spot_row, spot_col, max_radius, platform, flag_samespot, paired_genes, all_genes, verbose)
}

#' Pairwise Moran's I with Custom Dense Weight Matrix
#'
#' Computes pairwise Moran's I using a user-provided dense weight matrix.
#' Uses population SD (N) for z-normalization to match SpaCET.
#'
#' @param data Gene expression matrix (genes x spots), raw values
#' @param W Dense weight matrix (spots x spots)
#' @param mode Computation mode: "paired" (0), "single" (1), "first" (2)
#' @param verbose Print progress messages
#'
#' @return List with moran matrix, gene_names placeholder, and weight_sum
#'
#' @export
cpp_pairwise_moran_custom <- function(data, W, mode = 0L, verbose = TRUE) {
    .Call(`_sigdiscov_cpp_pairwise_moran_custom`, data, W, mode, verbose)
}

#' Pairwise Moran's I with Custom Sparse Weight Matrix
#'
#' Computes pairwise Moran's I using a user-provided sparse weight matrix.
#' Uses population SD (N) for z-normalization to match SpaCET.
#' More memory efficient than dense version for large datasets.
#'
#' @param data Gene expression matrix (genes x spots), raw values
#' @param W Sparse weight matrix (spots x spots)
#' @param mode Computation mode: "paired" (0), "single" (1), "first" (2)
#' @param verbose Print progress messages
#'
#' @return List with moran matrix, gene_names placeholder, and weight_sum
#'
#' @export
cpp_pairwise_moran_custom_sparse <- function(data, W, mode = 0L, verbose = TRUE) {
    .Call(`_sigdiscov_cpp_pairwise_moran_custom_sparse`, data, W, mode, verbose)
}

#' Find Neighbors Within Radius Using KD-Tree (Native C++)
#'
#' Uses nanoflann for O(n log n) neighbor search. No R dependencies required.
#'
#' @param coords Cell coordinates (n x 2 matrix)
#' @param radius Search radius
#' @param max_neighbors Maximum neighbors to return per point (default: 200)
#' @return List with nn_idx (1-indexed) and nn_dist matrices
#' @export
find_neighbors_radius_cpp <- function(coords, radius, max_neighbors = 200L) {
    .Call(`_sigdiscov_find_neighbors_radius_cpp`, coords, radius, max_neighbors)
}

#' Compute Pairwise Moran's I for Large Datasets (Native C++)
#'
#' Complete native C++ implementation using nanoflann for neighbor search.
#' No R package dependencies (RANN not required).
#'
#' @param data Gene expression matrix (genes x cells)
#' @param coords Cell coordinates (n x 2 matrix)
#' @param radius Radius for neighbor search
#' @param sigma Gaussian sigma (default: radius/3)
#' @param max_neighbors Maximum neighbors per cell (default: 200)
#' @param verbose Print progress messages (default: TRUE)
#' @return List with moran matrix, weight_sum, and n_edges
#' @export
pairwise_moran_native_cpp <- function(data, coords, radius, sigma = -1.0, max_neighbors = 200L, verbose = TRUE) {
    .Call(`_sigdiscov_pairwise_moran_native_cpp`, data, coords, radius, sigma, max_neighbors, verbose)
}

#' Compute Pairwise Moran's I Using Chunked Dense Approach (No Neighbor Limit)
#'
#' Similar to Python GPU implementation: processes senders in chunks,
#' computes dense distance matrix for each chunk, extracts sparse entries.
#' No neighbor limit - finds ALL neighbors within radius.
#'
#' Two-pass approach for memory efficiency:
#' - Pass 1: Compute row sums only (for normalization)
#' - Pass 2: Extract normalized triplets and build sparse matrix
#'
#' @param data Gene expression matrix (genes x cells)
#' @param coords Cell coordinates (n x 2 matrix)
#' @param radius Radius for neighbor search
#' @param sigma Gaussian sigma (default: radius/3)
#' @param chunk_size Number of cells per chunk (default: 1000)
#' @param verbose Print progress messages (default: TRUE)
#' @return List with moran matrix, weight_sum, and n_edges
#' @export
pairwise_moran_chunked_cpp <- function(data, coords, radius, sigma = -1.0, chunk_size = 1000L, verbose = TRUE) {
    .Call(`_sigdiscov_pairwise_moran_chunked_cpp`, data, coords, radius, sigma, chunk_size, verbose)
}

#' Compute Pairwise Moran's I with Streaming Lag (No Neighbor Limit, No W Storage)
#'
#' Best approach for CPU: uses KD-tree for O(n log n) neighbor search,
#' computes spatial lag on-the-fly without storing weight matrix W.
#' Unlimited neighbors without memory explosion.
#'
#' Memory usage: O(n_genes × n_cells) for data + lag matrices only.
#' Uses OpenMP for parallel processing across cells when available.
#'
#' @param data Gene expression matrix (genes x cells)
#' @param coords Cell coordinates (n x 2 matrix)
#' @param radius Radius for neighbor search
#' @param sigma Gaussian sigma (default: radius/3)
#' @param n_threads Number of threads (default: 0 = auto, ignored if OpenMP unavailable)
#' @param verbose Print progress messages (default: TRUE)
#' @return List with moran matrix, weight_sum, and n_edges
#' @export
pairwise_moran_streaming_cpp <- function(data, coords, radius, sigma = -1.0, n_threads = 0L, verbose = TRUE) {
    .Call(`_sigdiscov_pairwise_moran_streaming_cpp`, data, coords, radius, sigma, n_threads, verbose)
}

#' Compute Pairwise Moran's I with Chunked Dense BLAS (Best for Large Radii)
#'
#' Uses chunked dense matrix operations with BLAS for efficient computation
#' when many neighbors per cell. Processes cells in batches to limit memory.
#'
#' For each chunk of cells, computes dense weight matrix and uses optimized
#' BLAS matrix multiplication for spatial lag. Much faster than streaming
#' when density > 5% (i.e., > n/20 neighbors per cell).
#'
#' @param data Gene expression matrix (genes x cells)
#' @param coords Cell coordinates (n x 2 matrix)
#' @param radius Radius for neighbor search
#' @param sigma Gaussian sigma (default: radius/3)
#' @param chunk_size Cells per chunk (default: 500, tune for memory)
#' @param verbose Print progress messages (default: TRUE)
#' @return List with moran matrix, weight_sum, and n_edges
#' @export
pairwise_moran_dense_cpp <- function(data, coords, radius, sigma = -1.0, chunk_size = 500L, verbose = TRUE) {
    .Call(`_sigdiscov_pairwise_moran_dense_cpp`, data, coords, radius, sigma, chunk_size, verbose)
}

#' Streaming Permutation Test for Pairwise Moran's I (Memory Efficient)
#'
#' Performs permutation test without storing dense weight matrix.
#' Uses KD-tree neighbor lists to compute spatial lag on-the-fly for each
#' permutation, accumulating statistics incrementally.
#'
#' Memory usage: O(n_cells × avg_neighbors) for neighbor lists +
#'               O(n_genes × n_cells) for data/lag + O(n_genes²) for accumulators
#'
#' For 98k cells with 5k neighbors: ~1.7 GB instead of 77 GB with dense W.
#'
#' @param data Gene expression matrix (genes x cells). Will be z-normalized.
#' @param coords Cell coordinates (n x 2 matrix)
#' @param radius Radius for Gaussian weights
#' @param sigma Gaussian sigma (default: radius/3)
#' @param n_perm Number of permutations (default: 999)
#' @param seed Random seed (0 = random, default: 0)
#' @param verbose Print progress messages (default: TRUE)
#' @return List with observed, sum, sum_sq, count_extreme, weight_sum, n_edges
#' @export
allpairs_permutation_streaming_cpp <- function(data, coords, radius, sigma = -1.0, n_perm = 999L, seed = 0L, verbose = TRUE) {
    .Call(`_sigdiscov_allpairs_permutation_streaming_cpp`, data, coords, radius, sigma, n_perm, seed, verbose)
}

#' Permutation Test for Spatial Correlation (Single Gene)
#'
#' Tests H0: No spatial association between factor and gene expression.
#' The test permutes factor expression while keeping the spatial lag fixed.
#'
#' @param z_f Standardized factor expression vector (length n)
#' @param lag_g Pre-computed spatial lag of gene (W * z_g), same length as z_f
#' @param metric String: "moran" for bivariate Moran's I, "ind" for I_ND
#' @param n_perm Number of permutations (default: 999)
#'
#' @return List with components:
#'   - I_obs: Observed statistic value
#'   - p_value: Two-sided p-value with continuity correction
#'   - z_score: Z-score relative to null distribution
#'   - null_mean: Mean of null distribution
#'   - null_sd: Standard deviation of null distribution
#'   - n_perm: Number of permutations performed
#'
#' @details
#' The permutation strategy is:
#' 1. Compute observed statistic from z_f and lag_g
#' 2. For b = 1 to n_perm:
#'    a. Randomly permute z_f
#'    b. Compute permuted statistic (lag_g stays fixed)
#' 3. p-value = (1 + count(|I_perm| >= |I_obs|)) / (n_perm + 1)
#'
#' The continuity correction (+1 in numerator and denominator) ensures
#' p-values are never exactly 0.
#'
#' @export
permutation_test_cpp <- function(z_f, lag_g, metric, n_perm) {
    .Call(`_sigdiscov_permutation_test_cpp`, z_f, lag_g, metric, n_perm)
}

#' Batch Permutation Test for Multiple Genes
#'
#' Efficiently tests all genes against one factor. Pre-generates permutation
#' indices once and reuses them across all genes.
#'
#' @param z_f Standardized factor expression vector (length n_obs)
#' @param Z_g Gene expression matrix (n_obs x n_genes), genes in columns
#' @param W Sparse weight matrix (n_obs x n_obs) for computing spatial lags
#' @param metric String: "moran" or "ind"
#' @param n_perm Number of permutations (default: 999)
#' @param weight_sum Sum of weights for normalization. If <= 0, uses n_obs.
#'
#' @return DataFrame with columns:
#'   - gene_idx: Gene index (1-based)
#'   - I_obs: Observed statistic (Moran's I or I_ND)
#'   - p_value: Two-sided p-value
#'   - z_score: Z-score relative to null
#'   - null_sd: Standard deviation of the null distribution
#'
#' @details
#' Key optimizations:
#' 1. Permutation indices are generated ONCE and reused for all genes
#' 2. Spatial lag is computed once per gene
#' 3. User interrupt is checked every 100 genes
#'
#' This function is the workhorse for genome-wide significance testing.
#' For a typical analysis with 20,000 genes and 999 permutations, this
#' processes approximately 20 million permutation statistics.
#'
#' @export
batch_permutation_test_cpp <- function(z_f, Z_g, W, metric, n_perm, weight_sum = -1.0) {
    .Call(`_sigdiscov_batch_permutation_test_cpp`, z_f, Z_g, W, metric, n_perm, weight_sum)
}

#' All-Pairs Permutation Test for Pairwise Moran's I
#'
#' Fast C++ implementation of permutation testing for the full pairwise
#' Moran's I matrix. This function is called by the R wrapper moran_permutation_test().
#'
#' @param data_z Z-normalized expression matrix (genes x spots)
#' @param W Dense weight matrix (spots x spots)
#' @param S0 Sum of all weights
#' @param n_perm Number of permutations
#' @param seed Random seed for reproducibility (0 = use random seed)
#' @param verbose Print progress messages
#'
#' @return List containing:
#'   - sum: Sum of Moran's I across permutations
#'   - sum_sq: Sum of squared Moran's I
#'   - count_extreme: Count of permutations with |I_perm| >= |I_obs|
#'   - observed: Observed Moran's I matrix
#'
#' @keywords internal
allpairs_permutation_test_cpp <- function(data_z, W, S0, n_perm, seed = 0L, verbose = TRUE) {
    .Call(`_sigdiscov_allpairs_permutation_test_cpp`, data_z, W, S0, n_perm, seed, verbose)
}

#' Fast Pairwise Moran's I Computation
#'
#' Computes pairwise Moran's I for all gene pairs using optimized BLAS
#' matrix operations.
#'
#' @param data_z Z-normalized expression matrix (genes x spots)
#' @param W Weight matrix (spots x spots)
#' @param S0 Sum of all weights
#'
#' @return Moran's I matrix (genes x genes)
#'
#' @keywords internal
pairwise_moran_matrix_cpp <- function(data_z, W, S0) {
    .Call(`_sigdiscov_pairwise_moran_matrix_cpp`, data_z, W, S0)
}

#' Z-Normalize Expression Matrix
#'
#' Z-normalizes each row (gene) of the expression matrix.
#'
#' @param X Expression matrix (genes x spots)
#'
#' @return Z-normalized matrix
#'
#' @keywords internal
z_normalize_matrix_cpp <- function(X) {
    .Call(`_sigdiscov_z_normalize_matrix_cpp`, X)
}

#' Univariate Moran's I for Each Gene
#'
#' Computes univariate Moran's I for each gene (diagonal of pairwise matrix).
#'
#' @param data_z Z-normalized expression matrix (genes x spots)
#' @param W Weight matrix (spots x spots)
#' @param S0 Sum of all weights
#'
#' @return Vector of Moran's I values
#'
#' @keywords internal
single_gene_moran_cpp <- function(data_z, W, S0) {
    .Call(`_sigdiscov_single_gene_moran_cpp`, data_z, W, S0)
}

#' Row-Normalize Sparse Matrix
#'
#' @param W Sparse matrix (n x m)
#' @return Row-normalized sparse matrix where each row sums to 1 (or 0)
sparse_row_normalize_cpp <- function(W) {
    .Call(`_sigdiscov_sparse_row_normalize_cpp`, W)
}

#' Create Gaussian Weight Matrix for Single-Cell Data
#'
#' Matches Python implementation: sigma = radius / 3
#'
#' @param sender_coords Sender cell coordinates (n_s x 2)
#' @param receiver_coords Receiver cell coordinates (n_r x 2)
#' @param radius Outer radius (micrometers)
#' @param inner_radius Inner radius for ring (default: 0)
#' @param sigma Gaussian sigma (default: radius/3)
#' @param min_weight Minimum weight threshold (default: 1e-6)
#' @return Sparse weight matrix (n_s x n_r), row-normalized
#' @export
create_gaussian_weights_cpp <- function(sender_coords, receiver_coords, radius, inner_radius = 0.0, sigma = -1.0, min_weight = 1e-6) {
    .Call(`_sigdiscov_create_gaussian_weights_cpp`, sender_coords, receiver_coords, radius, inner_radius, sigma, min_weight)
}

#' Create Gaussian Ring Weight Matrix
#'
#' Weight matrix for annular region between inner and outer radius.
#'
#' @param coords Cell coordinates (n x 2)
#' @param outer_radius Outer radius
#' @param inner_radius Inner radius
#' @param sigma Gaussian sigma (default: outer_radius/3)
#' @return Sparse weight matrix (n x n), row-normalized
#' @export
create_gaussian_ring_weights_cpp <- function(coords, outer_radius, inner_radius, sigma = -1.0) {
    .Call(`_sigdiscov_create_gaussian_ring_weights_cpp`, coords, outer_radius, inner_radius, sigma)
}

#' Create Sparse Weight Matrix from Pre-computed Neighbors
#'
#' Efficiently creates weight matrix from pre-computed neighbor indices
#' (e.g., from RANN k-NN search). Scales to millions of cells.
#'
#' @param nn_idx Neighbor index matrix (n x k) from RANN::nn2, 1-indexed
#' @param nn_dist Neighbor distance matrix (n x k) from RANN::nn2
#' @param sigma Gaussian sigma for weight computation
#' @param radius Maximum distance cutoff (neighbors beyond this are ignored)
#' @param row_normalize Whether to row-normalize weights (default: TRUE)
#' @param self_weight Weight for self-connections (default: 0, no self)
#' @return List with sparse weight matrix W and weight_sum
#' @export
create_weights_from_neighbors_cpp <- function(nn_idx, nn_dist, sigma, radius = -1.0, row_normalize = TRUE, self_weight = 0.0) {
    .Call(`_sigdiscov_create_weights_from_neighbors_cpp`, nn_idx, nn_dist, sigma, radius, row_normalize, self_weight)
}

#' Compute Pairwise Moran's I from Pre-computed Neighbors (Scalable)
#'
#' Computes pairwise Moran's I for large single-cell datasets using
#' pre-computed neighbors. Avoids O(n²) distance computation.
#'
#' @param data Gene expression matrix (genes x cells), will be z-normalized
#' @param nn_idx Neighbor index matrix (n_cells x k) from RANN, 1-indexed
#' @param nn_dist Neighbor distance matrix (n_cells x k) from RANN
#' @param sigma Gaussian sigma for weights
#' @param radius Maximum distance cutoff
#' @param verbose Print progress messages
#' @return List with moran matrix and weight_sum
#' @export
pairwise_moran_from_neighbors_cpp <- function(data, nn_idx, nn_dist, sigma, radius = -1.0, verbose = TRUE) {
    .Call(`_sigdiscov_pairwise_moran_from_neighbors_cpp`, data, nn_idx, nn_dist, sigma, radius, verbose)
}

#' Create Circular RBF Weight Matrix
#'
#' Computes a sparse weight matrix using RBF kernel with circular (Euclidean)
#' distance cutoff. This matches the SpaCET calWeights behavior.
#'
#' @param coords Spot coordinates matrix (n x 2), physical units (e.g., micrometers)
#' @param radius Distance cutoff. Only spots within this radius are connected.
#' @param sigma RBF kernel bandwidth. Default: 100.
#' @param include_self Include self-connections (diagonal). Default: FALSE.
#'
#' @return A list containing:
#'   \item{W}{Sparse weight matrix (n x n), NOT row-normalized}
#'   \item{weight_sum}{Sum of all weights (S0 for Moran's I normalization)}
#'
#' @details
#' The weight is computed as:
#' \deqn{w_{ij} = \exp\left(-\frac{d_{ij}^2}{2\sigma^2}\right) \text{ if } d_{ij} \leq r}
#'
#' where \eqn{d_{ij}} is the Euclidean distance between spots i and j.
#'
#' This function is designed to match SpaCET's calWeights behavior for
#' spatial correlation analysis.
#'
#' @export
create_circular_weights_cpp <- function(coords, radius, sigma = 100.0, include_self = FALSE) {
    .Call(`_sigdiscov_create_circular_weights_cpp`, coords, radius, sigma, include_self)
}

#' Create Circular RBF Weight Matrix (Dense Version)
#'
#' Same as create_circular_weights_cpp but returns a dense matrix.
#' Useful when sparsity is low or for compatibility with functions
#' expecting dense matrices.
#'
#' @param coords Spot coordinates matrix (n x 2)
#' @param radius Distance cutoff
#' @param sigma RBF kernel bandwidth. Default: 100.
#' @param include_self Include self-connections. Default: FALSE.
#'
#' @return A list containing:
#'   \item{W}{Dense weight matrix (n x n)}
#'   \item{weight_sum}{Sum of all weights}
#'
#' @export
create_circular_weights_dense_cpp <- function(coords, radius, sigma = 100.0, include_self = FALSE) {
    .Call(`_sigdiscov_create_circular_weights_dense_cpp`, coords, radius, sigma, include_self)
}

#' Create Binary Weight Matrix for Visium
#'
#' Computes a row-normalized binary weight matrix where all spots within
#' the specified radius receive equal weight.
#'
#' @param coords Spot coordinates matrix (n x 2)
#' @param radius Distance threshold for neighbor definition
#' @param include_self Include self-connections (default: FALSE)
#'
#' @return Sparse weight matrix (n x n), row-normalized so each row sums to 1
#'
#' @details
#' The weight is computed as:
#' \deqn{w_{ij} = \frac{1}{n_i} \text{ if } d(i,j) \leq r, \text{ else } 0}
#'
#' where \eqn{n_i} is the number of neighbors for spot i.
#'
#' @export
create_binary_weights_cpp <- function(coords, radius, include_self = FALSE) {
    .Call(`_sigdiscov_create_binary_weights_cpp`, coords, radius, include_self)
}

#' Create Ring Weight Matrix for Visium
#'
#' Computes a weight matrix where only spots in a ring (annulus) between
#' inner and outer radii receive weight. Useful for excluding immediate
#' neighbors or analyzing specific distance bands.
#'
#' @param coords Spot coordinates matrix (n x 2)
#' @param inner_radius Inner radius (exclusive)
#' @param outer_radius Outer radius (inclusive)
#'
#' @return Sparse ring weight matrix (n x n), row-normalized
#'
#' @details
#' Weight is assigned to spots where \eqn{r_{inner} < d(i,j) \leq r_{outer}}.
#'
#' @export
create_ring_weights_cpp <- function(coords, inner_radius, outer_radius) {
    .Call(`_sigdiscov_create_ring_weights_cpp`, coords, inner_radius, outer_radius)
}

#' Create Directional Weight Matrix (Sender to Receiver)
#'
#' Computes a weight matrix for directional analysis where senders and
#' receivers are different sets of spots. Used for expression-based
#' sender/receiver splitting in Visium analysis.
#'
#' @param sender_coords Sender spot coordinates (n_s x 2)
#' @param receiver_coords Receiver spot coordinates (n_r x 2)
#' @param radius Distance threshold
#'
#' @return Sparse weight matrix (n_senders x n_receivers), row-normalized
#'
#' @details
#' For directional mode, the weight matrix is not square. Each sender spot
#' gets connections to receiver spots within the radius, with row normalization
#' so that weights sum to 1 per sender.
#'
#' @export
create_directional_weights_cpp <- function(sender_coords, receiver_coords, radius) {
    .Call(`_sigdiscov_create_directional_weights_cpp`, sender_coords, receiver_coords, radius)
}

